{"ast":null,"code":"// Ensure jsPDF does not import on Server Side\nlet jsPDF = null;\n\nif (false) {\n  import(\"jspdf\").then(module => {\n    jsPDF = module.default;\n  });\n}\n\nconst exportQuestion = async (summary, answerList) => {\n  // Initialise the PDF document to write\n  let lMargin = 15; //left margin in mm\n\n  let rMargin = 15; //right margin in mm\n\n  let pdfInMM = 210; // width of A4 in mm\n\n  let doc = new jsPDF(\"p\", \"mm\", \"a4\");\n  let yPos = 55;\n  let maxYPos = 280; // Question Information\n\n  let questionTitle = \"Question Title: \" + summary[0];\n  let questionDescription = \"Question Description: \" + summary[1];\n  let reward = \"Reward: \" + summary[2] * 1e-4;\n  doc.setFontSize(18);\n  doc.text(lMargin, 45, \"Question Information\");\n  doc.setLineWidth(0.2);\n  doc.line(lMargin, 47, 190, 47);\n  let lineHeight = doc.getLineHeight(questionDescription) / doc.internal.scaleFactor; // Question Title\n\n  let splittedText = doc.splitTextToSize(questionTitle, pdfInMM - lMargin - rMargin);\n  doc.setFontSize(13);\n  doc.text(lMargin, yPos, splittedText); // Question Description\n\n  let lines = splittedText.length;\n  lineHeight = doc.getLineHeight(splittedText) / doc.internal.scaleFactor;\n  let blockHeight = lines * lineHeight;\n  yPos += blockHeight;\n  splittedText = doc.splitTextToSize(questionDescription, pdfInMM - lMargin - rMargin);\n  doc.text(lMargin, yPos, splittedText); // Question Reward\n\n  lines = splittedText.length;\n  lineHeight = doc.getLineHeight(splittedText) / doc.internal.scaleFactor;\n  blockHeight = lines * lineHeight;\n  yPos += blockHeight;\n  splittedText = doc.splitTextToSize(reward, pdfInMM - lMargin - rMargin);\n  doc.text(lMargin, yPos, splittedText); // Question's Images\n\n  lines = splittedText.length;\n  blockHeight = lines * lineHeight;\n  yPos += lineHeight;\n  splittedText = doc.splitTextToSize(\"Link(s) of Image(s) Uploaded For Question:\", pdfInMM - lMargin - rMargin);\n  doc.setFontType('bold');\n  doc.text(lMargin, yPos, splittedText);\n\n  if (summary[5].length != 0) {\n    summary[5].map((imageHash, index) => {\n      let link = \"https://ipfs.io/ipfs/\" + imageHash;\n      lines = splittedText.length;\n      blockHeight = lines * lineHeight;\n      yPos += lineHeight;\n      lines = doc.splitTextToSize(link, pdfInMM - lMargin - rMargin);\n      doc.setFontSize(13);\n      doc.setFontType('normal');\n      doc.text(lMargin, yPos, lines);\n    });\n  } // Answer Header\n\n\n  lines = splittedText.length;\n  blockHeight = lines * lineHeight;\n  yPos += lineHeight * 2;\n  splittedText = doc.splitTextToSize(\"Answer(s) Provided\", pdfInMM - lMargin - rMargin);\n  doc.setFontSize(18);\n  doc.setFontType('normal');\n  doc.text(lMargin, yPos, splittedText);\n  lines = splittedText.length;\n  blockHeight = lines * lineHeight;\n  yPos += lineHeight * 0.3;\n  doc.setLineWidth(0.2);\n  doc.line(lMargin, yPos, 190, yPos); // Answer Body\n\n  if (answerList.length != 0) {\n    answerList.map((answer, index) => {\n      let answerAddress = answer[2];\n      let content = answer[0];\n      let numOfApprovals = answer[4];\n      let rewarded = answer[1];\n      let answerLine = answerAddress + \": \" + content;\n      let approvalLine = \"Number of Approvals: \" + numOfApprovals;\n      let rewardedLine = \"Rewarded: \" + rewarded; // Answers\n\n      lineHeight = doc.getLineHeight(splittedText) / doc.internal.scaleFactor;\n      lines = splittedText.length;\n      blockHeight = lines * lineHeight;\n\n      if (yPos > maxYPos) {\n        doc.addPage();\n        yPos = 40;\n      } else {\n        yPos += blockHeight;\n      }\n\n      splittedText = doc.splitTextToSize(answerLine, pdfInMM - lMargin - rMargin);\n      doc.setFontSize(12);\n      doc.setFontType('normal');\n      doc.text(lMargin, yPos, splittedText);\n\n      if (answer[8].length != 0) {\n        answer[8].map((imageHash, index) => {\n          let link = \"https://ipfs.io/ipfs/\" + imageHash;\n          lineHeight = doc.getLineHeight(splittedText) / doc.internal.scaleFactor;\n          lines = splittedText.length;\n          blockHeight = lines * lineHeight;\n          yPos += lineHeight;\n          splittedText = doc.splitTextToSize(link, pdfInMM - lMargin - rMargin);\n          doc.text(lMargin, yPos, splittedText);\n        });\n      } // Number Of Approvals\n\n\n      lineHeight = doc.getLineHeight(splittedText) / doc.internal.scaleFactor;\n      lines = splittedText.length;\n      blockHeight = lines * lineHeight;\n\n      if (yPos > maxYPos) {\n        doc.addPage();\n        yPos = 40;\n      } else {\n        yPos += blockHeight;\n      }\n\n      splittedText = doc.splitTextToSize(approvalLine, pdfInMM - lMargin - rMargin);\n      doc.text(lMargin, yPos, splittedText); // Rewarded Or Not\n\n      lineHeight = doc.getLineHeight(splittedText) / doc.internal.scaleFactor;\n      lines = splittedText.length;\n      blockHeight = lines * lineHeight;\n\n      if (yPos > maxYPos) {\n        doc.addPage();\n        yPos = 40;\n      } else {\n        yPos += blockHeight;\n      }\n\n      splittedText = doc.splitTextToSize(rewardedLine, pdfInMM - lMargin - rMargin);\n      doc.text(lMargin, yPos, splittedText);\n      yPos += lineHeight * 0.3;\n      doc.setLineWidth(0.1);\n      doc.line(lMargin, yPos, 190, yPos);\n    });\n  }\n\n  let pageCount = doc.internal.getNumberOfPages();\n  doc = createFooter(doc, pageCount);\n  doc = createHeader(doc, pageCount);\n  doc.save(\"EthQuestion_\" + summary[0] + \".pdf\");\n};\n\nconst exportComments = async comments => {\n  // Initialise the PDF document to write\n  let lMargin = 15; //left margin in mm\n\n  let rMargin = 15; //right margin in mm\n\n  let pdfInMM = 210; // width of A4 in mm\n\n  let doc = new jsPDF(\"p\", \"mm\", \"a4\");\n  let yPos = 55;\n  let maxYPos = 230; // Comments Header\n\n  doc.setFontSize(18);\n  let commentHeader = \"Comment(s) Provided By Users\";\n  let splittedText = doc.splitTextToSize(commentHeader, pdfInMM - lMargin - rMargin);\n  doc.text(lMargin, 45, splittedText);\n  doc.setLineWidth(0.2);\n  doc.line(lMargin, 47, 190, 47); // Comments Body\n\n  if (comments.length != 0) {\n    comments.map((comment, index) => {\n      let lineHeight = doc.getLineHeight(splittedText) / doc.internal.scaleFactor;\n      let lines = splittedText.length;\n      let blockHeight = lines * lineHeight;\n\n      if (yPos > maxYPos) {\n        doc.addPage();\n        yPos = 40;\n      } else {\n        yPos += blockHeight;\n      }\n\n      splittedText = doc.splitTextToSize(comment, pdfInMM - lMargin - rMargin);\n      doc.setFontSize(12);\n      doc.setFontType('normal');\n      doc.text(lMargin, yPos, splittedText);\n    });\n  }\n\n  let pageCount = doc.internal.getNumberOfPages();\n  doc = createFooter(doc, pageCount);\n  doc = createHeader(doc, pageCount);\n  doc.save(\"EthQuestion_Comments.pdf\");\n};\n\nconst createHeader = (document, pageCount) => {\n  for (let i = 1; i <= pageCount; i++) {\n    if (i == 1) {\n      document.setPage(i);\n      document.setTextColor(0);\n      document.setFontSize(24);\n      document.text(15, 30, \"Ethereum Question & Answering System\");\n      document.setLineWidth(0.5);\n      document.line(15, 33, 190, 33);\n    } else {\n      document.setPage(i);\n      document.setTextColor(150);\n      document.setFontSize(13);\n      document.text(105, 30, \"Ethereum Question & Answering System\");\n      document.setLineWidth(0.3);\n      document.line(15, 33, 190, 33);\n    }\n  }\n\n  return document;\n};\n\nconst createFooter = (document, pageCount) => {\n  for (let i = 1; i <= pageCount; i++) {\n    document.setPage(i);\n    document.setFontSize(13);\n    document.setTextColor(150);\n    document.text(170, 285, \"Page \" + document.internal.getCurrentPageInfo().pageNumber + \" of \" + pageCount);\n  }\n\n  return document;\n};\n\nexport { exportQuestion, exportComments };","map":null,"metadata":{},"sourceType":"module"}