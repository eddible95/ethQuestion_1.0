{"ast":null,"code":"var __jsx = React.createElement;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport React, { Component } from 'react';\nimport { Container, Segment, Header, Divider, Button, Popup, Form, Input, Icon, Dropdown, Table, Modal, Loader, Message, Transition, Grid } from \"semantic-ui-react\";\nimport Layout from '../components/Layout';\nimport LoadingModal from '../components/LoadingModal';\nimport AccountIssueModal from '../components/AccountIssueModal';\nimport TimeOutModal from '../components/TimeOutModal';\nimport { Router } from '../routes';\nimport { logging, checkRewardField } from '../utils/functions';\nimport web3 from '../ethereum/web3';\nimport factory from '../ethereum/factory';\nimport Profile from '../ethereum/profile';\nimport Question from '../ethereum/question';\nimport feedback from '../ethereum/feedback';\nimport EthQuestionToken from '../ethereum/token';\nimport EthQuestionTokenSale from '../ethereum/tokenSale';\nimport credentials from '../ethereum/credentials';\nimport { exportQuestion, exportComments } from '../utils/pdf';\nimport cookies from 'next-cookies';\n\nclass AdminPage extends Component {\n  constructor(props) {\n    super(props);\n\n    _defineProperty(this, \"export\", async () => {\n      // Check that a question must be selected\n      if (this.state.questionNumber != null) {\n        // Retrieve all the data of selected question\n        let questionNumber = Number(this.state.questionNumber) - 1;\n        let question = Question(this.state.deployedQuestions[questionNumber]);\n        let summary = await question.methods.getSummary().call();\n        let answerList = await question.methods.getAnswerList().call();\n        await exportQuestion(summary, answerList);\n      }\n    });\n\n    _defineProperty(this, \"exportFeedback\", async () => {\n      // Retrieve all comments\n      let comments = await feedback.methods.getComments().call();\n      await exportComments(comments);\n    });\n\n    _defineProperty(this, \"getUserTableData\", () => {\n      return this.state.ethWalletEmailAddressBinding.map((item, index) => {\n        return __jsx(Table.Row, {\n          key: index\n        }, __jsx(Table.Cell, null, item.ethWallet), __jsx(Table.Cell, null, item.emailAddress), __jsx(Table.Cell, null, item.status ? \"Blacklisted\" : \"Active\"), __jsx(Table.Cell, null, item.status ? __jsx(Button, {\n          onClick: () => this.unblacklist(item.emailAddress),\n          color: \"green\",\n          size: \"mini\",\n          icon: true\n        }, __jsx(Icon, {\n          name: \"add user\"\n        })) : __jsx(Button, {\n          onClick: () => this.blacklist(item.emailAddress),\n          color: \"red\",\n          size: \"mini\",\n          icon: true\n        }, __jsx(Icon, {\n          name: \"remove user\"\n        }))), __jsx(Table.Cell, null, __jsx(Button, {\n          onClick: () => this.dispense(item.ethWallet),\n          color: \"green\",\n          size: \"mini\",\n          icon: true\n        }, __jsx(Icon, {\n          name: \"ethereum\"\n        }))));\n      });\n    });\n\n    _defineProperty(this, \"blacklist\", async emailAddress => {\n      this.setState({\n        loading: true,\n        errorMessage: ''\n      });\n\n      try {\n        const account = this.state.account;\n        await credentials.methods.blacklistEmail(emailAddress).send({\n          from: account,\n          gasPrice: '0'\n        });\n        Router.pushRoute('/admin'); // Automatic redirect the user.\n      } catch (err) {\n        if (err.message == \"Returned error: authentication needed: password or unlock\") {\n          this.setState({\n            timeout: true\n          });\n        }\n\n        this.setState({\n          errorMessage: err.message\n        });\n        this.setState({\n          error: true\n        });\n      }\n\n      this.setState({\n        loading: false\n      });\n    });\n\n    _defineProperty(this, \"unblacklist\", async emailAddress => {\n      this.setState({\n        loading: true,\n        errorMessage: ''\n      });\n\n      try {\n        const account = this.state.account;\n        await credentials.methods.unBlacklistEmail(emailAddress).send({\n          from: account,\n          gasPrice: '0'\n        });\n      } catch (err) {\n        if (err.message == \"Returned error: authentication needed: password or unlock\") {\n          this.setState({\n            timeout: true\n          });\n        }\n\n        this.setState({\n          errorMessage: err.message\n        });\n        this.setState({\n          error: true\n        });\n      }\n\n      this.setState({\n        loading: false\n      });\n    });\n\n    _defineProperty(this, \"dispense\", async ethWallet => {\n      this.setState({\n        loading: true,\n        errorMessage: ''\n      });\n\n      try {\n        const account = this.state.account;\n        await EthQuestionToken.methods.transfer(ethWallet, 10e4).send({\n          from: account,\n          gasPrice: '0'\n        }); // Log transaction\n\n        const profileAddress = await factory.methods.getProfile(ethWallet).call();\n        const profile = Profile(profileAddress);\n        let logTransaction = logging(\"Awarded 10 EQT(s) for first time user\");\n        await profile.methods.logTransaction(logTransaction).send({\n          from: account,\n          gasPrice: '0'\n        });\n      } catch (err) {\n        if (err.message == \"Returned error: authentication needed: password or unlock\") {\n          this.setState({\n            timeout: true\n          });\n        }\n\n        this.setState({\n          errorMessage: err.message\n        });\n        this.setState({\n          error: true\n        });\n      }\n\n      this.setState({\n        loading: false\n      });\n    });\n\n    _defineProperty(this, \"getQuestionTableData\", () => {\n      return this.state.questionAddressTitleBinding.map((item, index) => {\n        return __jsx(Table.Row, {\n          key: index\n        }, __jsx(Table.Cell, null, item.questionAddress), __jsx(Table.Cell, null, item.title), __jsx(Table.Cell, null, item.flagged ? \"Flagged\" : \"Active\"), __jsx(Table.Cell, null, item.flagged ? __jsx(Button, {\n          onClick: () => this.undoDeleteQuestion(item.questionAddress),\n          color: \"green\",\n          size: \"mini\",\n          icon: true\n        }, __jsx(Icon, {\n          name: \"undo\"\n        })) : __jsx(Button, {\n          onClick: () => this.deleteQuestion(item.questionAddress),\n          color: \"red\",\n          size: \"mini\",\n          icon: true\n        }, __jsx(Icon, {\n          name: \"flag\"\n        }))));\n      });\n    });\n\n    _defineProperty(this, \"deleteQuestion\", async (questionAddress, title) => {\n      this.setState({\n        loading: true,\n        errorMessage: ''\n      });\n\n      try {\n        const account = this.state.account;\n        let logTransaction = logging(\"Deleted Question Titled: \" + title);\n        await factory.methods.deleteQuestion(questionAddress, logTransaction).send({\n          from: account,\n          gasPrice: '0'\n        });\n        Router.pushRoute('/admin'); // Automatic redirect the user.\n      } catch (err) {\n        if (err.message == \"Returned error: authentication needed: password or unlock\") {\n          this.setState({\n            timeout: true\n          });\n        }\n\n        this.setState({\n          errorMessage: err.message\n        });\n        this.setState({\n          error: true\n        });\n      }\n\n      this.setState({\n        loading: false\n      });\n    });\n\n    _defineProperty(this, \"undoDeleteQuestion\", async (questionAddress, title) => {\n      this.setState({\n        loading: true,\n        errorMessage: ''\n      });\n\n      try {\n        const account = this.state.account;\n        let logTransaction = logging(\"Undo Deletion Of Question Titled: \" + title);\n        await factory.methods.undoDeleteQuestion(questionAddress, logTransaction).send({\n          from: account,\n          gasPrice: '0'\n        });\n        Router.pushRoute('/admin'); // Automatic redirect the user.\n      } catch (err) {\n        if (err.message == \"Returned error: authentication needed: password or unlock\") {\n          this.setState({\n            timeout: true\n          });\n        }\n\n        this.setState({\n          errorMessage: err.message\n        });\n        this.setState({\n          error: true\n        });\n      }\n\n      this.setState({\n        loading: false\n      });\n    });\n\n    _defineProperty(this, \"topUp\", async () => {\n      this.setState({\n        loading: true,\n        errorMessage: ''\n      });\n\n      if (checkRewardField(this.state.topUpAmount)) {\n        try {\n          const account = this.state.account;\n          await web3.eth.personal.unlockAccount(account, \"password\", 600);\n          await EthQuestionToken.methods.transfer(EthQuestionTokenSale._address, this.state.topUpAmount * 1e4).send({\n            from: account,\n            gasPrice: '0'\n          }); // Log transaction\n\n          const profileAddress = await factory.methods.getProfile(account).call();\n          const profile = Profile(profileAddress);\n          let logTransaction = logging(\"Added \" + this.state.topUpAmount + \" EQT(s) for exchange\");\n          await profile.methods.logTransaction(logTransaction).send({\n            from: account,\n            gasPrice: '0'\n          });\n          Router.pushRoute('/admin'); // Automatic redirect the user.\n        } catch (err) {\n          if (err.message == \"Returned error: authentication needed: password or unlock\") {\n            this.setState({\n              timeout: true\n            });\n          }\n\n          this.setState({\n            errorMessage: err.message\n          });\n          this.setState({\n            error: true\n          });\n          this.setState({\n            loading: false\n          });\n        }\n      } else {\n        this.setState({\n          errorMessage: \"Required Field(s) Empty or Invalid Input\"\n        });\n        this.setState({\n          error: true\n        });\n        this.setState({\n          loading: false\n        });\n      }\n\n      this.setState({\n        loading: false\n      });\n    });\n\n    _defineProperty(this, \"collectEther\", async () => {\n      this.setState({\n        loading: true,\n        errorMessage: ''\n      });\n\n      try {\n        const account = this.state.account;\n        const profileAddress = await factory.methods.getProfile(account).call();\n        let logTransaction = logging(\"Collect Ether from exchange of EQT(s)\");\n        await EthQuestionTokenSale.methods.endSale(EthQuestionToken._address, profileAddress, logTransaction).send({\n          from: account,\n          gasPrice: '0'\n        });\n        Router.pushRoute('/admin'); // Automatic redirect the user.\n      } catch (err) {\n        if (err.message == \"Returned error: authentication needed: password or unlock\") {\n          this.setState({\n            timeout: true\n          });\n        }\n\n        this.setState({\n          errorMessage: err.message\n        });\n        this.setState({\n          error: true\n        });\n        this.setState({\n          loading: false\n        });\n      }\n\n      this.setState({\n        loading: false\n      });\n    });\n\n    _defineProperty(this, \"changeTokenPrice\", async () => {\n      this.setState({\n        loading: true,\n        errorMessage: ''\n      });\n\n      if (checkRewardField(this.state.newTokenPrice)) {\n        try {\n          const account = this.state.account;\n          const profileAddress = await factory.methods.getProfile(account).call();\n          let logTransaction = logging(\"Changed Token Price to \" + this.state.newTokenPrice + \" wei per EQT.\");\n          await EthQuestionTokenSale.methods.changeTokenPrice(this.state.newTokenPrice, profileAddress, logTransaction).send({\n            from: account,\n            gasPrice: '0'\n          });\n          Router.pushRoute('/admin'); // Automatic redirect the user.\n        } catch (err) {\n          if (err.message == \"Returned error: authentication needed: password or unlock\") {\n            this.setState({\n              timeout: true\n            });\n          }\n\n          this.setState({\n            errorMessage: err.message\n          });\n          this.setState({\n            error: true\n          });\n          this.setState({\n            loading: false\n          });\n        }\n      } else {\n        this.setState({\n          errorMessage: \"Required Field(s) Empty or Invalid Input\"\n        });\n        this.setState({\n          error: true\n        });\n        this.setState({\n          loading: false\n        });\n      }\n\n      this.setState({\n        loading: false\n      });\n    });\n\n    _defineProperty(this, \"toggleUserTableVisibility\", () => this.setState(prevState => ({\n      userVisible: !prevState.userVisible\n    })));\n\n    _defineProperty(this, \"toggleQuestionTableVisibility\", () => this.setState(prevState => ({\n      questionVisible: !prevState.questionVisible\n    })));\n\n    _defineProperty(this, \"toggleTokenManagementVisibility\", () => this.setState(prevState => ({\n      tokenManagementVisible: !prevState.tokenManagementVisible\n    })));\n\n    this.state = {\n      account: null,\n      error: false,\n      loading: false,\n      loadingResource: true,\n      timeout: false,\n      deployedQuestionsCount: null,\n      deployedQuestions: [],\n      ethWalletEmailAddressBinding: [],\n      questionAddressTitleBinding: [],\n      tokenPrice: null,\n      tokenBalance: null,\n      etherBalance: null,\n      errorMessage: '',\n      accountType: null,\n      userVisible: false,\n      questionOptions: [],\n      questionNumber: null,\n      questionVisible: false,\n      newTokenPrice: '',\n      topUpAmount: '',\n      tokenManagementVisible: false\n    };\n  }\n\n  static async getInitialProps(props) {\n    return {\n      isLogin: cookies(props).login || '',\n      account: cookies(props).wallet || ''\n    };\n  }\n\n  async componentDidUpdate(prevProps) {\n    if (this.props != prevProps) {\n      this.fetchData();\n    }\n  }\n\n  async componentDidMount() {\n    if (typeof web3 === 'undefined') {\n      this.setState({\n        loading: false\n      });\n      return;\n    }\n\n    let login = false;\n\n    if (this.props.isLogin) {\n      login = true; // Get Account Type\n\n      const account = this.props.account;\n      let profileAddress = await factory.methods.getProfile(account).call();\n      let profile = Profile(profileAddress);\n      let accountType = await profile.methods.getAccountType().call();\n      accountType == 0 ? accountType = \"Admin\" : accountType = \"User\";\n\n      if (accountType != \"Admin\") {\n        login = false;\n      }\n\n      await this.fetchData(); // Get Question Deployed\n\n      let questionOptions = [];\n\n      for (let i = 0; i < this.state.deployedQuestionsCount; i++) {\n        let question = Question(this.state.deployedQuestions[i]);\n        let summary = await question.methods.getSummary().call();\n        questionOptions.push({\n          key: i + 1,\n          text: summary[0],\n          value: i + 1\n        });\n      }\n\n      this.setState({\n        questionOptions: questionOptions\n      });\n      this.setState({\n        account: account\n      });\n      this.setState({\n        login: login\n      });\n      this.setState({\n        accountType: accountType\n      });\n    }\n\n    this.setState({\n      loadingResource: false\n    });\n  }\n\n  async fetchData() {\n    // Retrieve an array of addresses of questions deployed\n    let deployedQuestions = await factory.methods.getDeployedQuestions().call();\n    let deployedQuestionsCount = deployedQuestions.length;\n    let questionAddressTitleBinding = [];\n\n    for (let i = 0; i < deployedQuestionsCount; i++) {\n      let question = Question(deployedQuestions[i]);\n      let summary = await question.methods.getSummary().call();\n      questionAddressTitleBinding.push({\n        questionAddress: deployedQuestions[i],\n        title: summary[0],\n        flagged: summary[9]\n      });\n    } // Retrieve an array of EthWallets and Email Addresses\n\n\n    let ethWallets = await factory.methods.getEthWallets().call();\n    let ethWalletEmailAddressBinding = [];\n\n    for (let i = 0; i < ethWallets.length; i++) {\n      let emailAddress = await credentials.methods.getBinding(ethWallets[i]).call();\n      let status = await credentials.methods.emailNotBlackList(emailAddress).call();\n      ethWalletEmailAddressBinding.push({\n        ethWallet: ethWallets[i],\n        emailAddress: emailAddress,\n        status: status\n      });\n    }\n\n    let tokenPrice = await EthQuestionTokenSale.methods.getTokenPrice().call();\n    let tokenBalance = await EthQuestionToken.methods.balanceOf(EthQuestionTokenSale._address).call();\n    let etherBalance = await EthQuestionTokenSale.methods.getEtherBalance().call();\n    this.setState({\n      deployedQuestionsCount: deployedQuestionsCount,\n      deployedQuestions: deployedQuestions,\n      ethWalletEmailAddressBinding: ethWalletEmailAddressBinding,\n      questionAddressTitleBinding: questionAddressTitleBinding,\n      tokenPrice: tokenPrice,\n      tokenBalance: tokenBalance,\n      etherBalance: etherBalance\n    });\n  }\n\n  renderExport() {\n    return __jsx(React.Fragment, null, __jsx(Segment, {\n      raised: true,\n      textAlign: \"left\"\n    }, __jsx(Header, {\n      as: \"h2\",\n      textAlign: \"center\"\n    }, \"Exporting Questions & Answers As PDF\")), __jsx(Divider, {\n      hidden: true\n    }), __jsx(\"p\", {\n      style: {\n        fontSize: '16px'\n      }\n    }, \"Select the question to export the question and it's corresponding answers\"), __jsx(Dropdown, {\n      clearable: true,\n      options: this.state.questionOptions,\n      selection: true,\n      placeholder: \"Select the question to export\",\n      value: this.state.questionNumber,\n      onChange: (e, {\n        value\n      }) => this.setState({\n        questionNumber: value\n      })\n    }), __jsx(Button, {\n      icon: true,\n      labelPosition: \"left\",\n      color: \"red\",\n      onClick: this.export,\n      style: {\n        left: \"20px\"\n      }\n    }, __jsx(Icon, {\n      name: \"download\"\n    }), \"Export As PDF\"), __jsx(Divider, {\n      hidden: true\n    }), __jsx(Segment, {\n      raised: true,\n      textAlign: \"left\"\n    }, __jsx(Header, {\n      as: \"h2\",\n      textAlign: \"center\"\n    }, \"Exporting Feedback\")), __jsx(Button, {\n      icon: true,\n      labelPosition: \"left\",\n      color: \"red\",\n      onClick: this.exportFeedback,\n      style: {\n        left: \"20px\"\n      }\n    }, __jsx(Icon, {\n      name: \"download\"\n    }), \"Export As PDF\"));\n  }\n\n  renderEQTSettings() {\n    return __jsx(React.Fragment, null, __jsx(Segment, {\n      raised: true,\n      textAlign: \"center\"\n    }, __jsx(\"b\", {\n      style: {\n        fontSize: \"20px\"\n      }\n    }, \"EthQuestionTokens (EQT) Exchange Settings\"), __jsx(Popup, {\n      trigger: __jsx(Button, {\n        icon: this.state.tokenManagementVisible ? \"minus\" : \"plus\",\n        onClick: this.toggleTokenManagementVisibility,\n        floated: \"right\",\n        size: \"mini\"\n      }),\n      content: \"Click to expand/close\",\n      inverted: true\n    })), __jsx(Transition, {\n      visible: this.state.tokenManagementVisible,\n      animation: \"scale\",\n      duration: 500\n    }, __jsx(Grid, {\n      container: true\n    }, __jsx(Grid.Row, null, __jsx(\"p\", {\n      style: {\n        fontSize: '16px'\n      }\n    }, \"Balance Available For Exchange: \", __jsx(\"b\", null, this.state.tokenBalance * 1e-4, \" EQT(s)\"))), __jsx(Grid.Row, null, __jsx(Form, {\n      error: !!this.state.errorMessage,\n      style: {\n        marginTop: '10px'\n      }\n    }, __jsx(Form.Field, {\n      required: true\n    }, __jsx(\"label\", null, \"Top Up Amount\"), __jsx(Input, {\n      label: \"EQT(s)\",\n      labelPosition: \"right\",\n      placeholder: \"Enter EQT Value\",\n      value: this.state.topUpAmount,\n      onChange: event => this.setState({\n        topUpAmount: event.target.value\n      })\n    })))), __jsx(Grid.Row, null, __jsx(Button, {\n      icon: true,\n      labelPosition: \"left\",\n      color: \"red\",\n      onClick: this.topUp\n    }, __jsx(Icon, {\n      name: \"dollar sign\"\n    }), \"Top Up Balance\")), __jsx(Grid.Row, null, __jsx(\"p\", {\n      style: {\n        fontSize: '16px'\n      }\n    }, \"Ether Collected From Exchange: \", __jsx(\"b\", null, this.state.etherBalance * 1e-18, \" Ether(s)\"))), __jsx(Grid.Row, null, __jsx(Button, {\n      icon: true,\n      labelPosition: \"left\",\n      color: \"red\",\n      onClick: this.collectEther\n    }, __jsx(Icon, {\n      name: \"ethereum\"\n    }), \"Collect Ether\")), __jsx(Grid.Row, null, __jsx(\"p\", {\n      style: {\n        fontSize: '16px'\n      }\n    }, \"Current Token Price: \", __jsx(\"b\", null, this.state.tokenPrice * 1e-18, \" Ether(s)\"))), __jsx(Grid.Row, null, __jsx(Form, {\n      error: !!this.state.errorMessage,\n      style: {\n        marginTop: '10px'\n      }\n    }, __jsx(Form.Field, {\n      required: true\n    }, __jsx(\"label\", null, \"Token Price\"), __jsx(Input, {\n      label: \"Wei\",\n      labelPosition: \"right\",\n      placeholder: \"New Token Price\",\n      value: this.state.newTokenPrice,\n      onChange: event => this.setState({\n        newTokenPrice: event.target.value\n      })\n    })))), __jsx(Grid.Row, null, __jsx(Button, {\n      icon: true,\n      labelPosition: \"left\",\n      color: \"red\",\n      onClick: this.changeTokenPrice\n    }, __jsx(Icon, {\n      name: \"ethereum\"\n    }), \"Change Token Price\")))), __jsx(Divider, {\n      hidden: true\n    }));\n  }\n\n  renderUserManagement() {\n    return __jsx(React.Fragment, null, __jsx(Segment, {\n      raised: true,\n      textAlign: \"center\"\n    }, __jsx(\"b\", {\n      style: {\n        fontSize: \"20px\"\n      }\n    }, \"Users Management\"), __jsx(Popup, {\n      trigger: __jsx(Button, {\n        icon: this.state.userVisible ? \"minus\" : \"plus\",\n        onClick: this.toggleUserTableVisibility,\n        floated: \"right\",\n        size: \"mini\"\n      }),\n      content: \"Click to expand/close\",\n      inverted: true\n    })), __jsx(Divider, {\n      hidden: true\n    }), __jsx(Transition, {\n      visible: this.state.userVisible,\n      animation: \"scale\",\n      duration: 500\n    }, __jsx(Segment, null, __jsx(Header, null, __jsx(Icon, {\n      name: \"user\",\n      circular: true\n    }), \"Registered Users\"), __jsx(Table, {\n      compact: true,\n      celled: true,\n      stackable: true\n    }, __jsx(Table.Header, {\n      fullWidth: true\n    }, __jsx(Table.Row, null, __jsx(Table.HeaderCell, {\n      width: 2\n    }, \"Ethereum Wallet\"), __jsx(Table.HeaderCell, {\n      width: 3\n    }, \"Email\"), __jsx(Table.HeaderCell, {\n      width: 2\n    }, \"Status\"), __jsx(Table.HeaderCell, {\n      width: 2\n    }, \"Blacklist\"), __jsx(Table.HeaderCell, {\n      width: 2\n    }, \"Dispense Tokens\"))), __jsx(Table.Body, null, this.getUserTableData()), __jsx(Table.Footer, {\n      fullWidth: true\n    }, __jsx(Table.Row, null, __jsx(Table.HeaderCell, {\n      colSpan: 5\n    })))))), __jsx(Divider, {\n      hidden: true\n    }), __jsx(Segment, {\n      raised: true,\n      textAlign: \"center\"\n    }, __jsx(\"b\", {\n      style: {\n        fontSize: \"20px\"\n      }\n    }, \"Removing Question\"), __jsx(Popup, {\n      trigger: __jsx(Button, {\n        icon: this.state.questionVisible ? \"minus\" : \"plus\",\n        onClick: this.toggleQuestionTableVisibility,\n        floated: \"right\",\n        size: \"mini\"\n      }),\n      content: \"Click to expand/close\",\n      inverted: true\n    })));\n  }\n\n  renderQuestionSettings() {\n    return __jsx(React.Fragment, null, __jsx(Transition, {\n      visible: this.state.questionVisible,\n      animation: \"scale\",\n      duration: 500\n    }, __jsx(Segment, null, __jsx(Header, null, __jsx(Icon, {\n      name: \"question circle\",\n      circular: true\n    }), \"Questions Posted\"), __jsx(Table, {\n      compact: true,\n      celled: true,\n      stackable: true\n    }, __jsx(Table.Header, {\n      fullWidth: true\n    }, __jsx(Table.Row, null, __jsx(Table.HeaderCell, {\n      width: 2\n    }, \"Question Address\"), __jsx(Table.HeaderCell, {\n      width: 3\n    }, \"Title\"), __jsx(Table.HeaderCell, {\n      width: 2\n    }, \"Status\"), __jsx(Table.HeaderCell, {\n      width: 2\n    }, \"Actions\"))), __jsx(Table.Body, null, this.getQuestionTableData()), __jsx(Table.Footer, {\n      fullWidth: true\n    }, __jsx(Table.Row, null, __jsx(Table.HeaderCell, {\n      colSpan: 5\n    })))))));\n  }\n\n  render() {\n    if (this.state.login) {\n      return __jsx(Layout, {\n        accountType: this.state.accountType,\n        page: \"Admin\"\n      }, __jsx(Container, null, __jsx(Divider, {\n        hidden: true\n      }), this.renderExport(), this.renderEQTSettings(), __jsx(Message, {\n        error: true,\n        header: \"Oops!\",\n        content: this.state.errorMessage,\n        hidden: !this.state.error\n      }), this.renderUserManagement(), __jsx(Divider, {\n        hidden: true\n      }), this.renderQuestionSettings(), __jsx(Divider, {\n        hidden: true\n      }), __jsx(LoadingModal, {\n        trigger: this.state.loading,\n        title: 'Performing Admin Actions',\n        content: \"Please wait patiently as the system performs the action selected. This process might take awhile.\",\n        loader: \"Loading\"\n      })), __jsx(TimeOutModal, {\n        timeout: this.state.timeout\n      }));\n    } else {\n      return __jsx(Layout, {\n        accountType: this.state.accountType\n      }, __jsx(AccountIssueModal, {\n        loading: this.state.loadingResource,\n        login: this.state.login\n      }));\n    }\n  }\n\n}\n\nexport default AdminPage;","map":null,"metadata":{},"sourceType":"module"}