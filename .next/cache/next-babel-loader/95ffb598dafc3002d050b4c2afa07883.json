{"ast":null,"code":"var __jsx = React.createElement;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport moment from 'moment';\nimport React, { Component } from 'react';\nimport Countdown from 'react-countdown-now';\nimport { Context, Text } from 'react-mathjax2';\nimport { Table, Popup, Button, Container, Form, Header, Comment, Segment, Message, Divider, Icon, Label, Modal, Loader, Image, Grid } from 'semantic-ui-react';\nimport AccountIssueModal from '../components/AccountIssueModal';\nimport TimeOutModal from '../components/TimeOutModal';\nimport ErrorModal from '../components/ErrorModal';\nimport LoadingModal from '../components/LoadingModal';\nimport web3 from '../ethereum/web3';\nimport Question from '../ethereum/question';\nimport EthQuestionToken from '../ethereum/token';\nimport credentials from '../ethereum/credentials';\nimport Profile from '../ethereum/profile';\nimport factory from '../ethereum/factory';\nimport Layout from '../components/Layout';\nimport Footer from '../components/Footer';\nimport { Link, Router } from '../routes';\nimport { getIpfsHash } from '../utils/ipfs';\nimport { logging, checkFieldEmpty, sortingAnswers } from \"../utils/functions\";\nimport cookies from 'next-cookies';\n\nclass QuestionRow extends Component {\n  constructor(props) {\n    super(props);\n\n    _defineProperty(this, \"votePhase\", async () => {\n      try {\n        if (this.state.questionState == 0) {\n          const accounts = await web3.eth.getAccounts();\n          const question = Question(this.state.questionAddress); // Ensure that only Creator of Question can access this function\n\n          const account = this.props.account;\n\n          if (account == (await question.methods.getCreator().call())) {\n            this.setState({\n              changeToVoting: true\n            });\n            let logTransaction = logging(\"Change to Voting Phase for Question Titled: \" + this.state.summary[0]);\n            await factory.methods.changeQuestionPhase(this.state.questionAddress, logTransaction).send({\n              from: account,\n              gasPrice: '0'\n            });\n            Router.pushRoute(`/questions/${this.state.questionAddress}`);\n          } else {\n            this.setState({\n              ownerError: true\n            });\n          }\n        }\n      } catch (err) {\n        if (err.message == \"Returned error: authentication needed: password or unlock\") {\n          this.setState({\n            timeout: true\n          });\n        }\n\n        this.setState({\n          errorMessage: err.message\n        });\n      }\n\n      this.setState({\n        changeToVoting: false\n      });\n    });\n\n    _defineProperty(this, \"rewardPhase\", async () => {\n      try {\n        if (this.state.questionState == 1) {\n          const accounts = await web3.eth.getAccounts();\n          const question = Question(this.state.questionAddress); // Ensure that only Creator of Question can access this function\n\n          const account = this.props.account;\n\n          if (account == (await question.methods.getCreator().call())) {\n            this.setState({\n              changeToRewarded: true\n            });\n            let logTransaction = logging(\"Awarded \" + this.state.summary[2] * 1e-4 + \" EQT(s) as reward for Question Titled: \" + this.state.summary[0]);\n            let rewardMessage = logging(\"Rewarded \" + this.state.summary[2] * 1e-4 + \" EQT(s) for most approved answer\");\n            let voteMessage = logging(\"Rewarded EQT(s) for approving the most approved answer\");\n            let refundMessage = logging(\"Refunded \" + this.state.summary[2] * 1e-4 + \" EQT(s) as there are no answers or answers with approvals\");\n            await factory.methods.shareTokenAt(this.state.questionAddress, logTransaction, rewardMessage, voteMessage, refundMessage, EthQuestionToken._address).send({\n              from: account,\n              gasPrice: '0'\n            });\n            Router.pushRoute(`/questions/${this.state.questionAddress}`);\n          } else {\n            this.setState({\n              ownerError: true\n            });\n          }\n        }\n      } catch (err) {\n        if (err.message == \"Returned error: authentication needed: password or unlock\") {\n          this.setState({\n            timeout: true\n          });\n        }\n\n        this.setState({\n          errorMessage: err.message\n        });\n      }\n\n      this.setState({\n        changeToRewarded: false\n      });\n    });\n\n    _defineProperty(this, \"fixBalance\", async () => {\n      try {\n        const accounts = await web3.eth.getAccounts();\n        const question = Question(this.state.questionAddress); // Ensure that only Creator of Question can access this function\n\n        const account = this.props.account;\n\n        if (account == (await question.methods.getCreator().call())) {\n          this.setState({\n            fixError: true\n          });\n          let balance = this.state.summary[2] - (await EthQuestionToken.methods.balanceOf(this.state.questionAddress).call());\n          await EthQuestionToken.methods.transfer(this.state.questionAddress, balance).send({\n            from: account,\n            gasPrice: '0'\n          });\n          Router.pushRoute(`/home`);\n        } else {\n          this.setState({\n            ownerError: true\n          });\n        }\n      } catch (err) {\n        if (err.message == \"Returned error: authentication needed: password or unlock\") {\n          this.setState({\n            timeout: true\n          });\n        }\n\n        this.setState({\n          errorMessage: err.message\n        });\n      }\n\n      this.setState({\n        fixError: false\n      });\n    });\n\n    _defineProperty(this, \"timeExtension\", async () => {\n      try {\n        const accounts = await web3.eth.getAccounts();\n        const question = Question(this.state.questionAddress); // Ensure that only Creator of Question can access this function\n\n        const account = this.props.account;\n\n        if (account == (await question.methods.getCreator().call())) {\n          this.setState({\n            timeExtension: true\n          });\n          let logTransaction = logging(\"Duration Extended for Question Titled: \" + this.state.summary[0]);\n          await factory.methods.timeExtension(this.state.questionAddress, logTransaction).send({\n            from: account,\n            gasPrice: '0'\n          });\n          Router.pushRoute(`/questions/${this.state.questionAddress}`);\n        } else {\n          this.setState({\n            ownerError: true\n          });\n        }\n      } catch (err) {\n        if (err.message == \"Returned error: authentication needed: password or unlock\") {\n          this.setState({\n            timeExtension: false\n          });\n          this.setState({\n            timeout: true\n          });\n        }\n\n        this.setState({\n          errorMessage: err.message\n        });\n      }\n\n      this.setState({\n        timeExtension: false\n      });\n    });\n\n    _defineProperty(this, \"increaseReward\", async () => {\n      try {\n        const accounts = await web3.eth.getAccounts();\n        const question = Question(this.state.questionAddress); // Ensure that only Creator of Question can access this function\n\n        const account = this.props.account;\n\n        if (account == (await question.methods.getCreator().call())) {\n          this.setState({\n            changeReward: true\n          });\n          let logTransaction = logging(\"Increase Reward by 1 EQT(s) for Question Titled: \" + this.state.summary[0]);\n          await factory.methods.increaseReward(this.state.questionAddress, logTransaction, EthQuestionToken._address).send({\n            from: account,\n            gasPrice: '0'\n          });\n          await EthQuestionToken.methods.transfer(this.state.questionAddress, 10e3).send({\n            from: account,\n            gasPrice: '0'\n          });\n          Router.pushRoute(`/questions/${this.state.questionAddress}`);\n        } else {\n          this.setState({\n            ownerError: true\n          });\n        }\n      } catch (err) {\n        if (err.message == \"Returned error: authentication needed: password or unlock\") {\n          this.setState({\n            timeout: true\n          });\n        }\n\n        this.setState({\n          errorMessage: err.message\n        });\n      }\n\n      this.setState({\n        changeReward: false\n      });\n    });\n\n    _defineProperty(this, \"onSubmitAnswer\", async () => {\n      this.setState({\n        loading: true,\n        errorMessage: ''\n      });\n\n      if (checkFieldEmpty(this.state.answer)) {\n        try {\n          const question = Question(this.state.questionAddress); // Ensure that creator of question cannot provide answers\n\n          const account = this.props.account;\n\n          if (account != (await question.methods.getCreator().call()) && !(await question.methods.checkIfAnswered(account).call())) {\n            // Logs the transactions\n            let logTransaction = logging(\"Submitted Answer for Question Titled: \" + this.state.summary[0]); // Create new answer\n\n            await factory.methods.createAnswer(this.state.questionAddress, this.state.answer, this.state.fileHashes_array, this.state.fileNames_array, logTransaction).send({\n              from: account,\n              gasPrice: '0'\n            });\n            Router.pushRoute(`/questions/${this.state.questionAddress}`);\n          } else {\n            this.setState({\n              loading: false,\n              errorMessage: \"You cannot provide answer for your own question or already provided answer.\"\n            });\n          }\n        } catch (err) {\n          if (err.message == \"Returned error: authentication needed: password or unlock\") {\n            this.setState({\n              timeout: true\n            });\n          }\n\n          this.setState({\n            errorMessage: err.message\n          });\n        }\n      } else {\n        this.setState({\n          loading: false,\n          errorMessage: \"Answer Field Empty\"\n        });\n      }\n\n      this.setState({\n        loading: false,\n        answer: ''\n      });\n    });\n\n    _defineProperty(this, \"approveAnswer\", async answerer => {\n      this.setState({\n        voting: true\n      });\n      const account = this.props.account;\n      const question = await Question(this.state.questionAddress);\n      const profile = await factory.methods.getProfile(account).call();\n      const answerList = await question.methods.getAnswerList().call();\n      let index;\n\n      for (let i = 0; i < answerList.length; i++) {\n        if (answerList[i][2] == answerer) {\n          index = i;\n        }\n      } //Ensure that voter is not the answerer\n\n\n      try {\n        if (account != answerer) {\n          // Cannot vote twice\n          if (!(await question.methods.checkVoter(index, profile).call())) {\n            //No cost for voting after the voting phase\n            if ((await question.methods.state().call()) != 2) {\n              await EthQuestionToken.methods.transfer((await this.state.questionAddress), 10e3).send({\n                from: account,\n                gasPrice: '0'\n              });\n            }\n\n            let logTransaction = logging(\"Approved An Answer for Question Titled: \" + this.state.summary[0]);\n            await factory.methods.approveAnswer(this.state.questionAddress, index, logTransaction).send({\n              from: account,\n              gasPrice: '0'\n            });\n            Router.pushRoute(`/questions/${this.state.questionAddress}`);\n          } else {\n            this.setState({\n              voteMultipleError: true\n            });\n          }\n        } else {\n          this.setState({\n            voteError: true\n          });\n        }\n      } catch (err) {\n        if (err.message == \"Returned error: authentication needed: password or unlock\") {\n          this.setState({\n            timeout: true\n          });\n        }\n\n        this.setState({\n          errorMessage: err.message\n        });\n      }\n\n      this.setState({\n        voting: false\n      });\n    });\n\n    _defineProperty(this, \"onFileSelected\", async () => {\n      // Access JavaScript FileReader() method for conversion to buffer\n      const reader = new FileReader();\n      const file = this.fileInput.files[0];\n      this.setState({\n        fileLoading: true\n      });\n\n      if (file instanceof Blob) {\n        let {\n          files_array,\n          fileNames_array,\n          fileHashes_array\n        } = this.state;\n        files_array.push(file);\n        fileNames_array.push(file.name);\n        this.setState({\n          files_array: files_array,\n          fileNames_array: fileNames_array\n        });\n        console.log(\"fileNames_array: \", fileNames_array);\n\n        reader.onloadend = async () => {\n          await this.setState({\n            fileUrl: reader.result,\n            fileLoading: true,\n            buffer: Buffer.from(reader.result) // File is converted to a buffer for upload to IPFS\n\n          });\n          const fileHash = this.state.buffer ? await getIpfsHash(file) : '0';\n          fileHashes_array.push(fileHash);\n          this.setState({\n            fileHashes_array: fileHashes_array\n          });\n          console.log(\"fileHashes_array: \", fileHashes_array);\n          this.setState({\n            fileLoading: false\n          });\n        };\n\n        reader.readAsDataURL(file);\n      }\n    });\n\n    _defineProperty(this, \"onFileRemoved\", file => {\n      var i = 0;\n      let {\n        files_array,\n        fileHashes_array,\n        fileNames_array\n      } = this.state;\n      console.log('file: ', file);\n\n      for (i = 0; i < files_array.length; i++) {\n        if (file === files_array[i]) {\n          files_array.splice(i, 1);\n          fileNames_array.splice(i, 1);\n          fileHashes_array.splice(i, 1);\n          break;\n        }\n      }\n\n      this.setState({\n        files_array: files_array,\n        fileNames_array: fileNames_array,\n        fileHashes_array: fileHashes_array\n      });\n      console.log('fileNames_array', fileNames_array);\n      console.log(\"fileHashes_array: \", fileHashes_array);\n    });\n\n    this.state = {\n      questionAddress: '',\n      questionState: '',\n      summary: [],\n      time: '',\n      answerList: [],\n      avatarListIcon: [],\n      votingTime: '',\n      voting: false,\n      answer: '',\n      errorMessage: '',\n      loading: false,\n      voteError: false,\n      ownerError: false,\n      voteMultipleError: false,\n      changeToVoting: false,\n      changeToRewarded: false,\n      timeExtension: false,\n      changeReward: false,\n      fileLoading: false,\n      buffer: null,\n      files_array: [],\n      fileHashes_array: [],\n      fileNames_array: [],\n      login: false,\n      timeout: false,\n      resourceLoading: true,\n      accountType: null,\n      balanceError: false,\n      fixError: false,\n      sorted: false\n    };\n  }\n\n  static async getInitialProps(props) {\n    // Retrieve question data\n    let questionAddress = props.query.value;\n    return {\n      questionAddress,\n      isLogin: cookies(props).login || '',\n      account: cookies(props).wallet || ''\n    };\n  }\n\n  async componentDidMount() {\n    if (typeof web3 === 'undefined') {\n      this.setState({\n        resourceLoading: false\n      });\n      return;\n    }\n\n    let login = false;\n\n    if (this.props.isLogin) {\n      login = true; // Get Account Type\n\n      const account = this.props.account;\n      let profileAddress = await factory.methods.getProfile(account).call();\n      let profile = Profile(profileAddress);\n      let accountType = await profile.methods.getAccountType().call();\n      accountType == 0 ? accountType = \"Admin\" : accountType = \"User\";\n      await this.fetchQuestionData();\n      this.setState({\n        login: login,\n        accountType: accountType\n      });\n    }\n\n    this.setState({\n      resourceLoading: false\n    });\n  }\n\n  async componentDidUpdate(prevProps) {\n    if (this.props != prevProps) {\n      this.fetchQuestionData();\n    }\n  }\n\n  async fetchQuestionData() {\n    let error = false;\n    const questionAddress = this.props.questionAddress;\n    const question = Question(questionAddress); // Fetch Question Information\n\n    const summary = await question.methods.getSummary().call();\n    const time = await question.methods.getTime().call();\n    const answerList = await question.methods.getAnswerList().call(); // Fetch Avatar Icons\n\n    const iconList = ['alligator', 'anteater', 'armadillo', 'auroch', 'axolotl', 'badger', 'bat', 'beaver', 'buffalo', 'camel', 'capybara', 'chameleon', 'cheetah', 'chinchilla', 'chipmunk', 'chupacabra', 'cormorant', 'coyote', 'crow', 'dingo', 'dinosaur', 'dolphin', 'duck', 'elephant', 'ferret', 'fox', 'frog', 'giraffe', 'gopher', 'grizzly', 'hedgehog', 'hippo', 'hyena', 'ibex', 'ifrit', 'iguana', 'jackal', 'kangaroo', 'koala', 'kraken', 'lemur', 'leopard', 'liger', 'llama', 'manatee', 'mink', 'monkey', 'moose', 'narwhal', 'orangutan', 'otter', 'panda', 'penguin', 'platypus', 'pumpkin', 'python', 'quagga', 'rabbit', 'raccoon', 'rhino', 'sheep', 'shrew', 'skunk', 'squirrel', 'tiger', 'turtle', 'walrus', 'wolf', 'wolverine', 'wombat'];\n    const avatarListIcon = iconList.map(item => {\n      return 'https://ssl.gstatic.com/docs/common/profile/' + item + '_lg.png';\n    }); // Check for balance error\n\n    (await EthQuestionToken.methods.balanceOf(questionAddress).call()) != summary[2] ? error = true : error = false;\n    this.setState({\n      questionAddress: questionAddress,\n      questionState: summary[4],\n      summary: summary,\n      time: time,\n      avatarListIcon: avatarListIcon,\n      answerList: answerList.reverse(),\n      votingTime: time[3],\n      balanceError: error\n    });\n  }\n\n  // Render each tag individually for each question\n  renderTag(tagList, tagSize) {\n    const tagColours = [\"red\", \"olive\", \"blue\", \"teal\", \"green\"];\n    return tagList.map((tag, index) => {\n      let id = index % 5;\n      return __jsx(Label, {\n        as: \"a\",\n        onClick: () => Router.pushRoute(`/${'search/' + encodeURIComponent(tag)}`),\n        tag: true,\n        size: tagSize,\n        key: index,\n        color: tagColours[id]\n      }, tag);\n    });\n  }\n\n  renderQuestion() {\n    const summary = this.state.summary;\n    const time = this.state.time;\n    var currentTime = new Date().getTime();\n    var maxDuration = (parseFloat(summary[3]) / 60 / 60).toFixed(2).toString().toString();\n    var publishTime = moment.unix(time[0]).format('dddd, Do MMMM YYYY, h:mm:ss a');\n    var votingTime = moment.unix(this.state.votingTime).format('dddd, Do MMMM YYYY, h:mm:ss a');\n    var publishTimeMs = moment.unix(time[0]).valueOf();\n    var maxDurationMs = moment.unix(time[2]).valueOf();\n    var votingTimeMs = moment.unix(this.state.votingTime).valueOf();\n    let remainingTime = 0;\n\n    if (this.state.questionState == 0) {\n      remainingTime = publishTimeMs + maxDurationMs - currentTime;\n\n      if (remainingTime < 0) {\n        remainingTime = 0;\n      }\n    } else {\n      remainingTime = votingTimeMs + maxDurationMs - currentTime;\n\n      if (remainingTime < 0) {\n        remainingTime = 0;\n      }\n    }\n\n    return __jsx(React.Fragment, null, __jsx(Table, {\n      definition: true\n    }, __jsx(Table.Body, null, __jsx(Table.Row, null, __jsx(Table.Cell, {\n      width: 2\n    }, \"Question Title\"), __jsx(Table.Cell, {\n      style: {\n        fontSize: 20,\n        lineHeight: '1.5'\n      }\n    }, summary[0])), __jsx(Table.Row, null, __jsx(Table.Cell, {\n      width: 2\n    }, \"Description\"), __jsx(Table.Cell, {\n      style: {\n        fontSize: 20,\n        lineHeight: '1.5'\n      }\n    }, __jsx(Context, {\n      input: \"tex\",\n      onLoad: () => console.log(\"Loaded MathJax script!\"),\n      onError: (MathJax, error) => {\n        console.warn(error);\n        console.log(\"Encountered a MathJax error, re-attempting a typeset!\");\n        MathJax.Hub.Queue(MathJax.Hub.Typeset());\n      },\n      options: {\n        asciimath2jax: {\n          useMathMLspacing: true,\n          delimiters: [[\"$$\", \"$$\"]],\n          preview: \"none\"\n        }\n      }\n    }, __jsx(Text, {\n      text: summary[1]\n    })))), __jsx(Table.Row, null, __jsx(Table.Cell, {\n      width: 2\n    }, \"Tags\"), __jsx(Table.Cell, null, this.renderTag(summary[8], \"small\"))), __jsx(Table.Row, null, __jsx(Table.Cell, null, \"Reward (EQT)\"), __jsx(Table.Cell, {\n      style: {\n        fontSize: 20\n      }\n    }, summary[2] * 1e-4, this.state.questionState == 0 ? __jsx(Popup, {\n      trigger: __jsx(Button, {\n        style: {\n          float: 'right',\n          verticalAlign: 'middle'\n        },\n        icon: \"ethereum\",\n        color: \"black\",\n        onClick: this.increaseReward\n      }),\n      content: \"Increase Reward\",\n      position: \"bottom right\",\n      inverted: true\n    }) : __jsx(Popup, {\n      trigger: __jsx(Button, {\n        style: {\n          float: 'right',\n          verticalAlign: 'middle'\n        },\n        icon: \"ethereum\",\n        color: \"black\",\n        disabled: true\n      }),\n      position: \"bottom right\",\n      inverted: true\n    }))), __jsx(Table.Row, null, __jsx(Table.Cell, null, \"Publish Time\"), __jsx(Table.Cell, {\n      style: {\n        fontSize: 20\n      }\n    }, publishTime)), __jsx(Table.Row, null, __jsx(Table.Cell, null, \"Answering Duration (hours)\"), __jsx(Table.Cell, {\n      style: {\n        fontSize: 20\n      }\n    }, __jsx(\"span\", {\n      style: {\n        verticalAlign: 'middle',\n        lineHeight: '33px'\n      }\n    }, maxDuration), this.state.questionState == 0 && remainingTime > 0 ? __jsx(Popup, {\n      trigger: __jsx(Button, {\n        style: {\n          float: 'right',\n          verticalAlign: 'middle'\n        },\n        icon: \"clock\",\n        color: \"violet\"\n      }),\n      content: __jsx(\"span\", null, __jsx(\"span\", null, \"Remaining time - \"), __jsx(Countdown, {\n        date: Date.now() + remainingTime\n      })),\n      position: \"bottom right\",\n      inverted: true\n    }) : this.state.questionState == 0 && remainingTime == 0 ? __jsx(Popup, {\n      trigger: __jsx(Button, {\n        style: {\n          float: 'right',\n          verticalAlign: 'middle'\n        },\n        icon: \"clock\",\n        color: \"red\"\n      }),\n      flowing: true,\n      hoverable: true\n    }, __jsx(Grid, {\n      centered: true,\n      divided: true,\n      columns: 2\n    }, __jsx(Grid.Column, {\n      textAlign: \"center\"\n    }, __jsx(\"p\", null, \"Extends the validity of question by 1 hour\"), __jsx(Button, {\n      onClick: this.timeExtension\n    }, \"Extend Deadline\")), this.state.balanceError == true ? __jsx(Grid.Column, {\n      textAlign: \"center\"\n    }, __jsx(\"p\", null, \"Reward Balance Error\"), __jsx(Button, {\n      onClick: this.fixBalance\n    }, \"Fix Balance\")) : __jsx(Grid.Column, {\n      textAlign: \"center\"\n    }, __jsx(\"p\", null, \"Proceed to the voting phase\"), __jsx(Button, {\n      onClick: this.votePhase\n    }, \"Voting Phase\")))) : __jsx(Popup, {\n      trigger: __jsx(Button, {\n        style: {\n          float: 'right',\n          verticalAlign: 'middle'\n        },\n        icon: \"clock\",\n        color: \"red\",\n        disabled: true\n      }),\n      position: \"bottom right\",\n      inverted: true\n    }))), __jsx(Table.Row, null, __jsx(Table.Cell, null, \"Voting Duration (hours)\"), __jsx(Table.Cell, {\n      style: {\n        fontSize: 20\n      }\n    }, __jsx(\"span\", {\n      style: {\n        verticalAlign: 'middle',\n        lineHeight: '33px'\n      }\n    }, maxDuration), this.state.questionState == 1 && remainingTime > 0 ? __jsx(Popup, {\n      trigger: __jsx(Button, {\n        style: {\n          float: 'right',\n          verticalAlign: 'middle'\n        },\n        icon: \"clock\",\n        color: \"violet\"\n      }),\n      content: __jsx(\"span\", null, __jsx(\"span\", null, \"Remaining time - \"), __jsx(Countdown, {\n        date: Date.now() + remainingTime\n      })),\n      position: \"bottom right\",\n      inverted: true\n    }) : this.state.questionState == 1 && remainingTime == 0 ? __jsx(Popup, {\n      trigger: __jsx(Button, {\n        style: {\n          float: 'right',\n          verticalAlign: 'middle'\n        },\n        icon: \"clock\",\n        color: \"red\",\n        onClick: this.rewardPhase\n      }),\n      content: \"Reward\",\n      position: \"bottom right\",\n      inverted: true\n    }) : this.state.questionState == 0 ? __jsx(Popup, {\n      trigger: __jsx(Button, {\n        style: {\n          float: 'right',\n          verticalAlign: 'middle'\n        },\n        icon: \"clock\",\n        color: \"red\",\n        disabled: true\n      }),\n      position: \"bottom right\",\n      inverted: true\n    }) : __jsx(Popup, {\n      trigger: __jsx(Button, {\n        style: {\n          float: 'right',\n          verticalAlign: 'middle'\n        },\n        icon: \"clock\",\n        color: \"red\",\n        disabled: true\n      }),\n      position: \"bottom right\",\n      inverted: true\n    }))))));\n  }\n\n  renderAnswers() {\n    let answers = this.state.answerList;\n    answers = sortingAnswers(answers, this.state.sorted); // Answering Phase no answers are shown\n\n    if (this.state.questionState != 0) {\n      return answers.map((answer, index) => {\n        var answeredTime = moment.unix(answer[5]).format('Do MMMM YYYY, h:mm a');\n        var id = index % 70;\n        return __jsx(Comment, {\n          key: index\n        }, __jsx(Comment.Avatar, {\n          src: this.state.avatarListIcon[id],\n          style: {\n            backgroundColor: '#8D8741'\n          }\n        }), __jsx(Comment.Content, null, __jsx(Comment.Author, {\n          as: \"a\"\n        }, answer[2]), __jsx(Comment.Metadata, null, __jsx(\"div\", null, answeredTime)), __jsx(\"br\", null), answer[1] ? __jsx(\"b\", null, __jsx(\"font\", {\n          color: \"red\"\n        }, __jsx(Icon, {\n          name: \"certificate\"\n        }), \"Rewarded\")) : null, this.state.questionState == 2 ? __jsx(Comment.Metadata, null, __jsx(\"div\", null, __jsx(Icon, {\n          name: \"thumbs up\"\n        }), answer[4])) : __jsx(Comment.Metadata, null, __jsx(\"div\", null, __jsx(Icon, {\n          name: \"thumbs up\"\n        }), \"0\")), __jsx(Comment.Text, null, __jsx(Context, {\n          input: \"tex\",\n          onLoad: () => console.log(\"Loaded MathJax script!\"),\n          onError: (MathJax, error) => {\n            console.warn(error);\n            console.log(\"Encountered a MathJax error, re-attempting a typeset!\");\n            MathJax.Hub.Queue(MathJax.Hub.Typeset());\n          },\n          options: {\n            asciimath2jax: {\n              useMathMLspacing: true,\n              delimiters: [[\"$$\", \"$$\"]],\n              preview: \"none\"\n            }\n          }\n        }, __jsx(Text, {\n          text: answer[0]\n        })), answer[7].map((imageName, index) => __jsx(\"div\", {\n          style: {\n            marginBottom: '10px'\n          },\n          key: index\n        }, __jsx(Image, {\n          src: \"https://ipfs.io/ipfs/\" + answer[8][index],\n          centered: true\n        })))), __jsx(Comment.Actions, null, __jsx(Comment.Action, null, __jsx(Button, {\n          style: {\n            float: 'right',\n            verticalAlign: 'middle'\n          },\n          icon: \"thumbs up\",\n          onClick: () => this.approveAnswer(answer[2]),\n          size: \"tiny\",\n          content: \"Approve Answer\",\n          color: \"green\"\n        })))));\n      });\n    }\n  }\n\n  renderFiles() {\n    let fileHashes = this.state.summary[5];\n    let fileNames = this.state.summary[6];\n\n    if (fileHashes.length != 0) {\n      return __jsx(Segment, {\n        placeholder: true\n      }, __jsx(\"center\", null, __jsx(\"p\", null, \"Image(s) Uploaded\"), fileNames.map((fileName, index) => __jsx(\"div\", {\n        style: {\n          marginBottom: '10px'\n        },\n        key: index\n      }, __jsx(Image, {\n        src: \"https://ipfs.io/ipfs/\" + fileHashes[index],\n        size: \"massive\"\n      }), __jsx(Divider, {\n        hidden: true\n      }), __jsx(\"p\", null, \" To download: \"), __jsx(Label, {\n        as: \"a\",\n        size: \"big\",\n        href: \"https://ipfs.io/ipfs/\" + fileHashes[index]\n      }, __jsx(Icon, {\n        name: \"download\"\n      }), fileName)))));\n    }\n  }\n\n  renderAnswersForm() {\n    let {\n      files_array\n    } = this.state;\n    let elmFiles = null;\n\n    if (files_array !== null) {\n      elmFiles = files_array.map((item, index) => __jsx(Label, {\n        as: \"a\",\n        key: index,\n        size: \"big\"\n      }, item.name, __jsx(Icon, {\n        name: \"delete\",\n        onClick: () => this.onFileRemoved(item)\n      })));\n    }\n\n    return __jsx(Form, {\n      error: !!this.state.errorMessage\n    }, __jsx(Form.TextArea, {\n      placeholder: \"Enter Answers\",\n      value: this.state.answer,\n      onChange: event => this.setState({\n        answer: event.target.value\n      })\n    }), __jsx(Message, {\n      error: true,\n      header: \"Oops!\",\n      content: this.state.errorMessage\n    }), __jsx(Form.Field, null, this.renderFilesUpload(elmFiles)), __jsx(Modal, {\n      open: this.state.loading,\n      trigger: __jsx(Button, {\n        content: \"Submit Answers\",\n        onClick: this.onSubmitAnswer,\n        loading: this.state.loading,\n        labelPosition: \"left\",\n        icon: \"edit\",\n        primary: true\n      }),\n      basic: true,\n      size: \"small\"\n    }, __jsx(Header, {\n      content: \"Posting New Answers\"\n    }), __jsx(Modal.Content, null, __jsx(\"p\", null, \"Please wait patiently as the system is submitting your answer to the blockchain.\"), __jsx(Loader, {\n      active: true,\n      inline: \"centered\"\n    }, \"Loading\"))));\n  }\n\n  renderFilesUpload(files) {\n    let {\n      files_array\n    } = this.state;\n\n    if (this.state.files_array.length == 0) {\n      return __jsx(Container, null, __jsx(\"input\", {\n        style: {\n          display: 'none'\n        },\n        type: \"file\",\n        onChange: () => this.onFileSelected(),\n        ref: fileInput => this.fileInput = fileInput\n      }), __jsx(Button, {\n        primary: true,\n        onClick: () => this.fileInput.click(),\n        loading: this.state.fileLoading\n      }, \"Upload Image\"));\n    } else {\n      return __jsx(Segment, {\n        placeholder: true\n      }, __jsx(\"center\", null, __jsx(\"div\", {\n        style: {\n          marginBottom: '20px'\n        }\n      }, files), __jsx(\"input\", {\n        style: {\n          display: 'none'\n        },\n        type: \"file\",\n        onChange: () => this.onFileSelected(),\n        ref: fileInput => this.fileInput = fileInput\n      }), __jsx(Button, {\n        primary: true,\n        onClick: () => this.fileInput.click(),\n        loading: this.state.fileLoading\n      }, \"Upload Files\")));\n    }\n  }\n\n  render() {\n    if (this.state.login) {\n      return __jsx(Layout, {\n        accountType: this.state.accountType\n      }, __jsx(Container, null, __jsx(Divider, {\n        hidden: true\n      }), this.renderQuestion(), __jsx(Divider, {\n        hidden: true\n      }), this.renderFiles(), this.state.questionState == 1 ? __jsx(Container, null, __jsx(Header, {\n        as: \"h2\",\n        textAlign: \"center\"\n      }, \"Voting In Progress\"), __jsx(\"p\", {\n        style: {\n          textAlign: 'center',\n          fontSize: 20\n        }\n      }, \"No answers can be submitted\"), __jsx(Divider, null)) : __jsx(Header, {\n        as: \"h2\",\n        textAlign: \"center\"\n      }, \"Submit Your Answers Here\"), this.state.questionState == 1 ? null : __jsx(Container, null, __jsx(\"p\", null, __jsx(\"b\", null, \"Note:\"), \" To include math equations, delimit the latex format with $$.\"), __jsx(\"a\", {\n        style: {\n          display: \"table-cell\"\n        },\n        href: \"https://www.codecogs.com/latex/eqneditor.php\",\n        target: \"_blank\"\n      }, \"Link to Supported Latex Editor\")), this.state.questionState == 1 ? null : this.renderAnswersForm(), __jsx(Button, {\n        icon: this.state.sorted ? \"sort numeric down\" : \"sort numeric up\",\n        onClick: () => {\n          this.setState({\n            sorted: !this.state.sorted\n          });\n        },\n        floated: \"right\",\n        size: \"mini\"\n      }), __jsx(Header, {\n        as: \"h2\",\n        textAlign: \"center\"\n      }, \"Answer(s) Submitted: \", this.state.answerList.length), __jsx(Divider, null), __jsx(Comment.Group, {\n        size: \"large\"\n      }, this.renderAnswers()), __jsx(ErrorModal, {\n        error: this.state.voteError,\n        title: 'Cannot Approve Own Answers',\n        content: \"You have selected to approve the answer you have provided. Please only approve answers provided by others.\",\n        questionAddress: this.state.questionAddress,\n        stateChange: () => {\n          this.setState({\n            voteError: false\n          });\n        }\n      }), __jsx(ErrorModal, {\n        error: this.state.ownerError,\n        title: 'Only Available For Owner Of Question',\n        content: \"You cannot change the state of the question as you are not the owner.\",\n        questionAddress: this.state.questionAddress,\n        stateChange: () => {\n          this.setState({\n            ownerError: false\n          });\n        }\n      }), __jsx(ErrorModal, {\n        error: this.state.voteMultipleError,\n        title: 'Answer Already Approved',\n        content: \"You cannot approve the same answer more than once. Please approve another answer.\",\n        questionAddress: this.state.questionAddress,\n        stateChange: () => {\n          this.setState({\n            voteMultipleError: false\n          });\n        }\n      }), __jsx(ErrorModal, {\n        error: this.state.voteMultipleError,\n        title: 'Answer Already Approved',\n        content: \"You cannot approve the same answer more than once. Please approve another answer.\",\n        questionAddress: this.state.questionAddress,\n        stateChange: () => {\n          this.setState({\n            voteMultipleError: false\n          });\n        }\n      }), __jsx(LoadingModal, {\n        trigger: this.state.changeToVoting,\n        title: 'Changing Question State to Voting Phase',\n        content: \"Please wait patiently as the system changes your question state.\",\n        loader: \"Changing Question State\"\n      }), __jsx(LoadingModal, {\n        trigger: this.state.changeToRewarded,\n        title: 'Changing Question State to Rewarded Phase',\n        content: \"Please wait patiently as the system changes your question state.\",\n        loader: \"Changing Question State\"\n      }), __jsx(LoadingModal, {\n        trigger: this.state.timeExtension,\n        title: 'Extending Question Deadline',\n        content: \"Please wait patiently as the system extends the duration of your question.\",\n        loader: \"Extending Deadline\"\n      }), __jsx(LoadingModal, {\n        trigger: this.state.changeReward,\n        title: 'Increasing Reward',\n        content: \"Please wait patiently as the system increases the reward of your question.\",\n        loader: \"Increasing Reward\"\n      }), __jsx(LoadingModal, {\n        trigger: this.state.voting,\n        title: 'Approving Answer',\n        content: \"Please wait patiently as the system submits your approval.\",\n        loader: \"Approving\"\n      }), __jsx(LoadingModal, {\n        trigger: this.state.fixError,\n        title: 'Fixing Balance Error',\n        content: \"Please wait as the system fixes the balance error of your question.\",\n        loader: \"Fixing Balance\"\n      }), __jsx(TimeOutModal, {\n        timeout: this.state.timeout\n      })));\n    } else {\n      return __jsx(Layout, {\n        accountType: this.state.accountType\n      }, __jsx(AccountIssueModal, {\n        loading: this.state.resourceLoading,\n        login: this.state.login\n      }));\n    }\n  }\n\n}\n\nexport default QuestionRow;","map":null,"metadata":{},"sourceType":"module"}