{"ast":null,"code":"// Using the ipfs.infura.io node\nconst IPFS = require('ipfs-http-client');\n\nconst ipfs = new IPFS({\n  host: 'ipfs.infura.io',\n  port: 5001,\n  protocol: 'https'\n}); // Save document to IPFS and returns its hash value to be stored on the blockchain\n\nconst getIpfsHash = data => {\n  return new Promise((resolve, reject) => {\n    ipfs.add(data, (error, result) => {\n      if (error) {\n        return reject(error);\n      }\n\n      resolve(result[0].hash);\n    });\n  });\n}; // Retrieve an image from the hash value\n\n\nconst convertToImage = hash => {\n  return new Promise((resolve, reject) => {\n    ipfs.cat(hash, (error, result) => {\n      if (error) {\n        return reject(error);\n      }\n\n      resolve(\"data:image/jpeg;base64,\" + Buffer(result).toString('base64'));\n    });\n  });\n}; // Retrieve the document from its hash value\n\n\nconst getString = hash => {\n  return new Promise((resolve, reject) => {\n    ipfs.cat(hash, (error, result) => {\n      if (error) {\n        return reject(error);\n      }\n\n      resolve(result.toString());\n    });\n  });\n};\n\nexport { ipfs, getIpfsHash, convertToImage, getString };","map":{"version":3,"sources":["C:/Users/edd1e/Desktop/ethQuestion_1.0/utils/ipfs.js"],"names":["IPFS","require","ipfs","host","port","protocol","getIpfsHash","data","Promise","resolve","reject","add","error","result","hash","convertToImage","cat","Buffer","toString","getString"],"mappings":"AAAA;AACA,MAAMA,IAAI,GAAGC,OAAO,CAAC,kBAAD,CAApB;;AACA,MAAMC,IAAI,GAAG,IAAIF,IAAJ,CAAS;AAAEG,EAAAA,IAAI,EAAE,gBAAR;AAA0BC,EAAAA,IAAI,EAAE,IAAhC;AAAsCC,EAAAA,QAAQ,EAAE;AAAhD,CAAT,CAAb,C,CAEA;;AACA,MAAMC,WAAW,GAAIC,IAAD,IAAU;AAC3B,SAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACpCR,IAAAA,IAAI,CAACS,GAAL,CAASJ,IAAT,EAAe,CAACK,KAAD,EAAQC,MAAR,KAAmB;AAC9B,UAAGD,KAAH,EAAU;AACN,eAAOF,MAAM,CAACE,KAAD,CAAb;AACH;;AACDH,MAAAA,OAAO,CAACI,MAAM,CAAC,CAAD,CAAN,CAAUC,IAAX,CAAP;AACH,KALD;AAMH,GAPM,CAAP;AAQF,CATD,C,CAWA;;;AACA,MAAMC,cAAc,GAAID,IAAD,IAAU;AAC9B,SAAO,IAAIN,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACpCR,IAAAA,IAAI,CAACc,GAAL,CAASF,IAAT,EAAe,CAACF,KAAD,EAAQC,MAAR,KAAmB;AAC9B,UAAGD,KAAH,EAAU;AACN,eAAOF,MAAM,CAACE,KAAD,CAAb;AACH;;AACDH,MAAAA,OAAO,CAAC,4BAA4BQ,MAAM,CAACJ,MAAD,CAAN,CAAeK,QAAf,CAAwB,QAAxB,CAA7B,CAAP;AACH,KALD;AAMH,GAPM,CAAP;AAQF,CATD,C,CAWA;;;AACA,MAAMC,SAAS,GAAIL,IAAD,IAAU;AACzB,SAAO,IAAIN,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACpCR,IAAAA,IAAI,CAACc,GAAL,CAASF,IAAT,EAAe,CAACF,KAAD,EAAQC,MAAR,KAAmB;AAC9B,UAAGD,KAAH,EAAU;AACN,eAAOF,MAAM,CAACE,KAAD,CAAb;AACH;;AACDH,MAAAA,OAAO,CAACI,MAAM,CAACK,QAAP,EAAD,CAAP;AACH,KALD;AAMH,GAPM,CAAP;AAQF,CATD;;AAYA,SAAQhB,IAAR,EAAcI,WAAd,EAA2BS,cAA3B,EAA2CI,SAA3C","sourcesContent":["// Using the ipfs.infura.io node\r\nconst IPFS = require('ipfs-http-client');\r\nconst ipfs = new IPFS({ host: 'ipfs.infura.io', port: 5001, protocol: 'https' });\r\n\r\n// Save document to IPFS and returns its hash value to be stored on the blockchain\r\nconst getIpfsHash = (data) => {\r\n   return new Promise((resolve, reject) => {\r\n       ipfs.add(data, (error, result) => {\r\n           if(error) {\r\n               return reject(error);\r\n           }\r\n           resolve(result[0].hash);\r\n       })\r\n   });\r\n}\r\n\r\n// Retrieve an image from the hash value\r\nconst convertToImage = (hash) => {\r\n   return new Promise((resolve, reject) => {\r\n       ipfs.cat(hash, (error, result) => {\r\n           if(error) {\r\n               return reject(error);\r\n           }\r\n           resolve(\"data:image/jpeg;base64,\" + Buffer(result).toString('base64'));\r\n       })\r\n   });\r\n}\r\n\r\n// Retrieve the document from its hash value\r\nconst getString = (hash) => {\r\n   return new Promise((resolve, reject) => {\r\n       ipfs.cat(hash, (error, result) => {\r\n           if(error) {\r\n               return reject(error);\r\n           }\r\n           resolve(result.toString());\r\n       })\r\n   });\r\n}\r\n\r\n\r\nexport {ipfs, getIpfsHash, convertToImage, getString};\r\n"]},"metadata":{},"sourceType":"module"}